/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import {
  useGLTF,
  CurveModifier,
  Text3D,
  CurveModifierRef,
} from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";

const yellow = "#FDD022";
const pink = "#E7749E";
const white = "#ffffff";
const blue = "#0196D9";
const orange = "#D97945";

interface IAprilTextProps {
  colors: string[];
  text: string;
}

const AprilText = ({ colors, text }: IAprilTextProps) => {
  const textWithKerning = text.split("").map((letter) => {
    switch (letter) {
      case "a":
        return { letter, kerning: 0.27 };
      case "p":
        return { letter, kerning: 0.27 };
      case "r":
        return { letter, kerning: 0.22 };
      case "i":
        return { letter, kerning: 0.15 };
      case "l":
        return { letter, kerning: 0.16 };
      case "u":
        return { letter, kerning: 0.27 };
      case "c":
        return { letter, kerning: 0.27 };
      case "k":
        return { letter, kerning: 0.27 };
      case "s":
        return { letter, kerning: 0.3 };
      default:
        return { letter, kerning: 0.2 };
    }
  });

  const textWithOffsets = textWithKerning.map((letter, index) => {
    const offset = textWithKerning
      .slice(0, index)
      .reduce((acc, curr) => acc + curr.kerning, 0);
    return { ...letter, offset };
  });

  return (
    <group>
      {textWithOffsets.map((letter, index) => (
        <AprilLetter
          key={index}
          color={colors[index % colors.length]}
          x={-letter.offset}
          text={letter.letter}
        />
      ))}
    </group>
  );
};

interface IAprilLetterProps {
  color: string;
  x: number;
  text: string;
}
const AprilLetter = ({ color, x, text }: IAprilLetterProps) => {
  return (
    <Text3D
      font="/fonts/Videophreak_Regular.json" // Make sure to use a valid font path
      scale={-0.3}
      bevelEnabled
      bevelThickness={0.05}
      bevelSize={0.01}
      bevelOffset={0}
      bevelSegments={64}
      position={[x, 0, 0]}
      rotation={[0, 0, 0]} // Rotate the text to correct orientation
    >
      {text}
      <meshPhysicalMaterial color={color} />
    </Text3D>
  );
};

function CircularText() {
  const textRef = useRef<THREE.Mesh>(null);
  const curvedPoints = [];
  const curvedPoints2 = [];
  const curvedPoints3 = [];
  const radius = 10;
  const segments = 50; // Increase this for smoother curves
  const curveRef = useRef<CurveModifierRef>(null);
  const curveRef2 = useRef<CurveModifierRef>(null);
  const curveRef3 = useRef<CurveModifierRef>(null);

  // every frame, move the sun around the cloud
  useFrame(() => {
    // setTextRotation(prev => new THREE.Euler(0, theta, 0))
    if (curveRef.current) {
      curveRef.current.moveAlongCurve(0.001);
    }
    if (curveRef2.current) {
      curveRef2.current.moveAlongCurve(0.001);
    }
    if (curveRef3.current) {
      curveRef3.current.moveAlongCurve(0.001);
    }
  });
  for (let i = 0; i < segments; i++) {
    const angle = (i / segments) * 2 * Math.PI;
    curvedPoints.push(
      new THREE.Vector3(Math.sin(angle) * radius, 0, -Math.cos(angle) * radius),
    );
    curvedPoints2.push(
      new THREE.Vector3(
        Math.sin(angle + (2 * Math.PI) / 3) * radius,
        0,
        -Math.cos(angle + (2 * Math.PI) / 3) * radius,
      ),
    );
    curvedPoints3.push(
      new THREE.Vector3(
        Math.sin(angle + (4 * Math.PI) / 3) * radius,
        0,
        -Math.cos(angle + (4 * Math.PI) / 3) * radius,
      ),
    );
  }

  return (
    <group>
      {/* <CurveModifier curve={curve} ref={curveRef}> */}
      <Text3D
        ref={textRef}
        font="/fonts/helvetiker_regular.typeface.json" // Make sure to use a valid font path
        size={-1.5}
        bevelEnabled
        bevelThickness={0.05}
        bevelSize={0.01}
        bevelOffset={0}
        bevelSegments={64}
        rotation={[0, 0, Math.PI]} // Rotate the text to correct orientation
      >
        April
        <meshPhysicalMaterial color="white" reflectivity={10} />
      </Text3D>
      <Text3D
        ref={textRef}
        font="/fonts/helvetiker_regular.typeface.json" // Make sure to use a valid font path
        size={-1.5}
        bevelEnabled
        bevelThickness={0.05}
        bevelSize={0.01}
        bevelOffset={0}
        bevelSegments={64}
        rotation={[0, 0, Math.PI]} // Rotate the text to correct orientation
      >
        Clucks
        <meshPhysicalMaterial color="red" reflectivity={10} />
      </Text3D>
      {/* </CurveModifier> */}
    </group>
  );
}

export const TextGroup = () => {
  const textRef = useRef<THREE.Group<THREE.Object3DEventMap>>(null);
  // every frame, slightly alter the position and z axis rotation of the text

  useFrame((state, delta) => {
    const t = state.clock.getElapsedTime();
    if (!textRef.current) return;
    textRef.current.position.y = -0.5 + Math.sin(t * 2) * 0.05;
    textRef.current.rotation.z = Math.PI + Math.sin(t * 3) * 0.05;
  });

  const colors = [yellow, pink, white, blue, orange];

  return (
    <group ref={textRef} position={[-1.35, -0.5, 0.3]}>
      <AprilText colors={colors} text={"april clucks"} />
    </group>
  );
};

useGLTF.preload("/models/scene-v1.glb");
